InstallGlobalFunction( "MAJORANA_AllEmbeddings",

    function(rep)

    local   x, gens, subgp, T, subrep, ex, i, ev;

    # Loop over the algebraproducts that are not yet known
    for x in Positions(rep.algebraproducts, false) do
        if rep.algebraproducts[x] = false then

            # Find the involutions that generate the subgroup that contains the vectors in this product
            gens := ShallowCopy(rep.setup.pairreps[x]);

            while ForAny(gens, i -> i > Size(rep.involutions)) do
                gens := Flat( rep.setup.coords{gens});
            od;

            subgp := Subgroup(rep.group, rep.involutions{gens});

            # If this subgroup is proper
            if Size(subgp) < Size(rep.group) then

                # If this subgroup is generated by involutions of the main rep
                T := Intersection(subgp, rep.involutions);
                if T <> [] and Size(Group(T)) = Size(subgp) then

                    ex := ShapesOfMajoranaRepresentationAxiomM8(subgp,T);

                    # If the shapes of the reps match then build the rep
                    for i in [1..Size(ex.shapes)] do
                        if IsSubsetSet(AsSet(rep.shape), AsSet(ex.shapes[i])) then

                            Info(   InfoMajorana, 10,
                                    STRINGIFY("Constructing subrep of ", StructureDescription(subgp) ) );

                            subrep := MajoranaRepresentation(ex,i,rep.axioms);

                            # Embed the constructed rep
                            MAJORANA_EmbedKnownRep(rep, subrep);
                        fi;
                    od;
                fi;
            fi;
        fi;
    od;

    # Find bases of the eigenvectors
    for i in rep.setup.orbitreps do
        for ev in RecNames(rep.evec[i]) do
            if Nrows(rep.evecs[i].(ev)) > 0 then
                rep.evecs[i].(ev) := MAJORANA_BasisOfEvecs(rep.evecs[i].(ev));
            fi;
        od;
    od;

    end );

InstallGlobalFunction( "MAJORANA_MaximalSubgps",

    function(rep,axioms)

    local   max, inv, i, j, ev, ex, subrep;

    max := MaximalSubgroupClassReps(rep.group);
    max := Filtered(max, x -> Size(x) > 12);

    inv := List(max, x -> Intersection(AsList(x), rep.involutions));
    inv := Filtered(DuplicateFreeList(inv), x -> x <> []);

    max := List(inv, Group);

    for i in [1..Size(max)] do
        ex := ShapesOfMajoranaRepresentationAxiomM8(max[i], inv[i]);
        for j in [1..Size(ex.shapes)] do
            if IsSubsetSet(AsSet(rep.shape), AsSet(ex.shapes[j])) then

                Info(   InfoMajorana, 10,
                        STRINGIFY("Constructing subrep of ", StructureDescription(ex.group) ) );

                subrep := MajoranaRepresentation(ex,j,axioms);

                MAJORANA_EmbedKnownRep(rep, subrep);
            fi;
        od;
    od;

    for i in rep.setup.orbitreps do
        for ev in RecNames(rep.evec[i]) do
            rep.evecs[i].(ev) := MAJORANA_BasisOfEvecs(rep.evecs[i].(ev));
        od;
    od;

    if Nrows(rep.nullspace) > 0 then
        rep.nullspace := ShallowCopy(MAJORANA_BasisOfEvecs(rep.nullspace));
    fi;

    end );

##
## For a given injective homomorphism <emb> from subrep.group to rep.group,
## if possible, find an automorphism of subrep.group such that the shapes and
## involutions of rep and subrep match. Otherwise, return false.
##

InstallGlobalFunction( "MAJORANA_CheckEmbedding",

    function(rep, subrep, emb)

    local   aut, g, aut_emb, im, i, x, pos1, pos2, k;

    aut := AutomorphismGroup(subrep.group);

    # For each automorphism of subrep.group
    for g in aut do

        # Compose the automorphism with the embedding
        aut_emb := CompositionMapping2(emb, g);

        # Check if the image of the involutions of the subrep is a subset of the
        # involutions of the rep
        im := AsSet(Image(aut_emb, subrep.involutions));
        if not IsSubsetSet(AsSet(rep.involutions), im) then
            return false;
        fi;

        # Check if the shape of the image of the subrep matches with the shape
        # of the rep
        for i in [1..Size(subrep.shape)] do
            if subrep.shape[i, 1] in ['2','3','4'] then

                x := subrep.setup.pairreps[i];

                im := OnPairs(subrep.involutions{x}, aut_emb);

                pos1 := Position(rep.involutions, im[1]);
                pos2 := Position(rep.involutions, im[2]);

                k := rep.setup.pairorbit[pos1, pos2];

                if subrep.shape[i] <> rep.shape[k] then
                    return false;
                fi;
            fi;
        od;

        # If both shape and involutions match, return the automorphism
        return g;
    od;

    return false;

    end);

InstallGlobalFunction( "MAJORANA_EmbedKnownRep",

    function( rep, subrep)

    local   embs,
            i,
            g,
            emb;

    embs := IsomorphicSubgroups(rep.group, subrep.group);

    # For each embedding of subrep.group into rep.group
    for i in [1..Size(embs)] do
        g := MAJORANA_CheckEmbedding(rep, subrep, embs[i]);

        # Use the group embedding to embed the algebras
        if g <> false then
            emb := CompositionMapping2(embs[i], g);

            MAJORANA_Embed(rep, subrep,  emb);
        fi;
    od;

    end );

    ##
    ## Here <g> is either a group element or a homomorphism from <subrep.group>
    ## to <rep.group>. In the first case, <subrep> = <rep> and the func
    ## return <g> as a permutation on <rep.setup.coords>. In the second case,
    ## returns <g> as a list sending <subrep.setup.coords> to <rep.setup.coords>.
    ##

    ## TODO this is only used in embedding, need to fix it so that it works for this purpose!

    InstallGlobalFunction( MAJORANA_FindPerm,

        function(g, rep, subrep)

        local   dim, i, list, im, sign, vec;

        dim := Size(subrep.setup.coords);
        list := [1..dim]*0;

        for i in [1..dim] do

            vec := subrep.setup.coords[i];

            if IsRowVector(vec) then

                im := list{vec};

                sign := 1;

                if im[1] < 0 then sign := -sign; im[1] := -im[1]; fi;
                if im[2] < 0 then sign := -sign; im[2] := -im[2]; fi;

                if im[1] > im[2] then im := im{[2,1]}; fi;

                list[i] := rep.setup.coordmap[ im ];

                if list[i] = fail then
                    list[i] := rep.setup.coordmap[ Product( rep.involutions{im} ) ];
                fi;
            else
                list[i] := rep.setup.coordmap[ rep.involutions[i]^g ];
            fi;
        od;

        return list;

        end);

InstallGlobalFunction( "MAJORANA_Embed",

    function(rep, subrep, emb)

    local   i, im, ev, k, g, v, sign, x, l;

    if not IsRowVector(emb) then
        emb := MAJORANA_FindPerm(emb, rep, subrep);
    fi;

    for i in [1..Size(subrep.algebraproducts)] do

        if subrep.setup.pairreps[i] <> fail then
            sign := 1;

            im := emb{subrep.setup.pairreps[i]};

            if im[1] < 0 then
                sign := -sign; im[1] := -im[1];
            fi;

            if im[2] < 0 then
                sign := -sign; im[2] := -im[2];
            fi;

            k := rep.setup.pairorbit[im[1], im[2]];

            if k < 0 then
                sign := -sign; k := -k;
            fi;

            g := SP_Inverse(rep.setup.pairconjelts[rep.setup.pairconj[im[1], im[2]]]);

            if not IsBound(rep.algebraproducts[k]) or rep.algebraproducts[k] = false then
                if subrep.algebraproducts[i] <> false then
                    v := MAJORANA_ImageVector(subrep.algebraproducts[i], emb, rep, subrep);
                    rep.algebraproducts[k] := sign*MAJORANA_ConjugateVec(v,g);
                fi;
            fi;

            if not IsBound(rep.innerproducts[k]) or rep.innerproducts[k] = false then
                if subrep.innerproducts[i] <> false then
                    rep.innerproducts[k] := sign*subrep.innerproducts[i];
                fi;
            fi;
        fi;
    od;

    for i in subrep.setup.orbitreps do

        k := emb[i];

        g := false;

        for x in List(rep.setup.conjelts, x -> SP_Inverse(x)) do
            if x[k] in rep.setup.orbitreps then
                g := x;
                break;
            fi;
        od;

        if g <> false then
            for ev in RecNames(subrep.evecs[i]) do
                if Nrows(subrep.evecs[i].(ev)) > 0 then
                    im := MAJORANA_ImageVector(subrep.evecs[i].(ev), emb, rep, subrep);
                    for l in [1..Nrows(im)] do
                        v := CertainRows(im, [l]);
                        v := MAJORANA_ConjugateVec(v, g);
                        rep.evecs[g[k]].(ev) := UnionOfRows(rep.evecs[g[k]].(ev), v);
                    od;
                fi;
            od;
        fi;
    od;

    end );

InstallGlobalFunction( "MAJORANA_ImageVector",

    function(mat, emb, rep, subrep)

    local   i,
            j,
            im,
            res,
            sign,
            pos,
            nrows,
            ncols,
            indices,
            entries;

    nrows := Nrows(mat);
    ncols := Ncols(mat);

    res := SparseZeroMatrix(nrows, ncols, Rationals);

    indices := IndicesOfSparseMatrix(mat);
    entries := EntriesOfSparseMatrix(mat);

    for i in [1..nrows] do
        for j in [1..Size(indices[i])] do

            sign := 1;;

            im := emb[indices[i, j]];

            if im < 0 then
                sign := -sign;
                im := -im;
            fi;

            SetEntry(res, i, im, sign*entries[i, j]);
        od;
    od;

    return res;

    end );

InstallGlobalFunction( MAJORANA_Image,

    function(rep, subrep, emb, x)

    local y, pos;

    if IsRowVector(x) then
        y := subrep.setup.coords{x};

        pos := List(y, i -> Position(rep.setup.longcoords, Image(emb, i))); # TODO fix signs

        return SortedList(rep.setup.poslist{pos});
    else
        return Image(emb, x);
    fi;

    end );
